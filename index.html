<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>流星许愿今日签</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    font-family: 'Microsoft YaHei', sans-serif;
    background: radial-gradient(ellipse at top, #0b0c2c 0%, #1b1f4d 100%);
  }
  #canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
  }
  #instructions {
    position: absolute;
    top: 20px;
    width: 100%;
    text-align: center;
    font-size: 18px;
    color: #fffacd;
    text-shadow: 0 0 10px #000;
    z-index: 2;
    animation: pulse 2s infinite;
  }
  @keyframes pulse {
    0% { opacity: 0.7; }
    50% { opacity: 1; }
    100% { opacity: 0.7; }
  }
  #fortuneContainer {
    position: absolute;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    z-index: 2;
  }
  .fortune-card {
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    padding: 25px 35px;
    border-radius: 15px;
    font-size: 20px;
    text-align: center;
    color: #fff;
    text-shadow: 0 0 5px #000;
    box-shadow: 0 0 20px #88f;
    animation: glow 2s infinite alternate;
    position: relative;
    overflow: hidden;
  }
  @keyframes glow {
    from { box-shadow: 0 0 10px #88f; }
    to { box-shadow: 0 0 20px #88f, 0 0 30px #88f; }
  }
  .fortune-card::before {
    content: '';
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    background: linear-gradient(45deg, #ff00cc, #3333ff, #00ccff, #33ff99);
    z-index: -1;
    filter: blur(20px);
    opacity: 0.5;
    animation: rotate 10s linear infinite;
  }
  @keyframes rotate {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  #storyBtn {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(10px);
    border: none;
    padding: 15px 35px;
    border-radius: 25px;
    font-size: 18px;
    color: #fff;
    cursor: pointer;
    transition: all 0.3s;
    z-index: 2;
  }
  #storyBtn:hover {
    background: rgba(255,255,255,0.4);
    transform: translateX(-50%) scale(1.05);
  }
  .constellation-name {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 24px;
    opacity: 0;
    transition: opacity 1s;
    text-shadow: 0 0 10px #88f;
    z-index: 2;
  }
  .sparkle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: white;
    border-radius: 50%;
    pointer-events: none;
    z-index: 1;
  }
</style>
</head>
<body>
<div id="instructions">点击天空，点亮 5 颗星，组成你的今日星座</div>
<canvas id="canvas"></canvas>
<div id="fortuneContainer">
  <div class="fortune-card" id="fortuneBox"></div>
</div>
<button id="storyBtn">进入故事册</button>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let stars = [];
let maxStars = 5;
let particles = [];
let meteors = [];
let constellationGlow = { active: false, radius: 0, alpha: 0 };
let sparkles = [];

// 星座名称
const constellationNames = [
  "希望之星", "幸运之环", "智慧之眼", "勇气之盾", "和谐之舞",
  "梦想之翼", "宁静之心", "繁荣之树", "友谊之桥", "真爱之结"
];

const fortunes = [
  "今天你会遇到小惊喜~", "心情会特别好，笑容满满", "运气不错，试试新的挑战", "有人暗中帮助你", "工作学习都顺利",
  "遇到好吃的美食", "心想事成的一天", "会收到小礼物", "幸运数字会出现", "适合出行",
  "有人欣赏你的努力", "财运不错，钱包轻松", "遇到有趣的人", "心情轻松愉快", "容易得到称赞",
  "有意外收获", "今天适合尝试新事物", "爱情小幸运", "精神状态极佳", "适合创作和动手",
  "容易交到朋友", "会遇到有趣的对话", "财务状况平稳", "好心情持续一整天", "小愿望实现",
  "今天适合整理计划", "有机会获得认可", "旅行心情愉快", "学习效率高", "人际顺利",
  "被夸奖的机会多", "适合表达自己", "小惊喜连连", "尝试新技能顺利", "健康状况良好",
  "心态积极", "工作进展顺利", "容易被人理解", "生活小确幸", "灵感频繁出现",
  "小心容易遗忘重要事情", "注意身体疲劳", "有点小波折，不要着急", "小误会可能发生", "财务小损失",
  "情绪容易波动", "容易错过机会", "争执小摩擦", "容易拖延", "需要多注意安全"
];

// 流星类 - 改进版
class Meteor {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.x = Math.random() * canvas.width;
    this.y = -20;
    this.speed = 2 + Math.random() * 3;
    this.length = 20 + Math.random() * 50;
    this.angle = Math.PI / 4 + (Math.random() * Math.PI / 8);
    this.active = true;
    this.alpha = 0.7 + Math.random() * 0.3;
    this.trail = [];
    this.width = 1 + Math.random() * 2;
  }
  
  update() {
    if (!this.active) return;
    
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;
    
    // 记录轨迹
    this.trail.push({x: this.x, y: this.y, alpha: this.alpha});
    if (this.trail.length > this.length) {
      this.trail.shift();
    }
    
    // 逐渐消失
    this.alpha -= 0.01;
    
    // 检查是否超出屏幕或完全消失
    if (this.x > canvas.width || this.y > canvas.height || this.alpha <= 0) {
      this.active = false;
    }
  }
  
  draw() {
    if (!this.active) return;
    
    ctx.save();
    
    // 绘制流星轨迹
    for (let i = 0; i < this.trail.length; i++) {
      const point = this.trail[i];
      const progress = i / this.trail.length;
      
      ctx.beginPath();
      ctx.moveTo(point.x, point.y);
      ctx.lineTo(
        point.x - Math.cos(this.angle) * 5, 
        point.y - Math.sin(this.angle) * 5
      );
      
      // 创建渐变
      const gradient = ctx.createLinearGradient(
        point.x, point.y,
        point.x - Math.cos(this.angle) * 5,
        point.y - Math.sin(this.angle) * 5
      );
      
      gradient.addColorStop(0, `rgba(255, 255, 255, ${point.alpha})`);
      gradient.addColorStop(1, `rgba(100, 150, 255, 0)`);
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = this.width * progress;
      ctx.stroke();
    }
    
    // 绘制流星头部
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.width * 1.5, 0, Math.PI * 2);
    const radialGradient = ctx.createRadialGradient(
      this.x, this.y, 0,
      this.x, this.y, this.width * 3
    );
    radialGradient.addColorStop(0, `rgba(255, 255, 255, ${this.alpha})`);
    radialGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
    ctx.fillStyle = radialGradient;
    ctx.fill();
    
    ctx.restore();
  }
}

// 粒子类
class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = Math.random() * 3 + 1;
    this.speedX = Math.random() * 2 - 1;
    this.speedY = Math.random() * 2 - 1;
    this.color = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`;
    this.life = 30;
  }
  
  update() {
    this.x += this.speedX;
    this.y += this.speedY;
    this.life--;
  }
  
  draw() {
    ctx.save();
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// 闪光粒子类
class Sparkle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = Math.random() * 4 + 2;
    this.speedX = (Math.random() - 0.5) * 2;
    this.speedY = (Math.random() - 0.5) * 2;
    this.life = 50;
    this.maxLife = 50;
  }
  
  update() {
    this.x += this.speedX;
    this.y += this.speedY;
    this.life--;
  }
  
  draw() {
    const progress = this.life / this.maxLife;
    ctx.save();
    ctx.globalAlpha = progress;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * progress, 0, Math.PI * 2);
    ctx.fill();
    
    // 添加光芒效果
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(
        this.x + Math.cos(i * Math.PI / 2) * this.size * 2 * progress,
        this.y + Math.sin(i * Math.PI / 2) * this.size * 2 * progress
      );
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    
    ctx.restore();
  }
}

class Star {
  constructor(x,y){
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.targetRadius = 6;
    this.brightness = 0;
    this.pulse = 0;
    this.pulseDirection = 1;
  }
  
  draw(){
    ctx.save();
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius + this.pulse, 0, Math.PI*2);
    ctx.fillStyle = `rgba(255,255,180,${this.brightness})`;
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 15;
    ctx.fill();
    
    // 添加星光效果
    if (this.brightness > 0.5) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI*2);
      const gradient = ctx.createRadialGradient(
        this.x, this.y, this.radius,
        this.x, this.y, this.radius * 2
      );
      gradient.addColorStop(0, `rgba(255, 255, 200, ${this.brightness * 0.5})`);
      gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
      ctx.fillStyle = gradient;
      ctx.fill();
    }
    
    ctx.restore();
  }
  
  update(){
    if(this.radius < this.targetRadius) this.radius += 0.3;
    if(this.brightness < 1) this.brightness += 0.05;
    
    // 脉动效果
    if (this.brightness > 0.8) {
      this.pulse += 0.05 * this.pulseDirection;
      if (this.pulse > 1 || this.pulse < 0) {
        this.pulseDirection *= -1;
      }
    }
    
    this.draw();
  }
}

function connectStars(){
  ctx.beginPath();
  ctx.strokeStyle = 'rgba(180,220,255,0.7)';
  ctx.lineWidth = 2;
  ctx.shadowBlur = 10;
  ctx.shadowColor = "rgba(180,220,255,0.7)";
  for(let i=0;i<stars.length-1;i++){
    ctx.moveTo(stars[i].x,stars[i].y);
    ctx.lineTo(stars[i+1].x,stars[i+1].y);
  }
  ctx.stroke();
  
  // 在线条上添加粒子
  if (stars.length > 1) {
    for (let i = 0; i < stars.length - 1; i++) {
      const start = stars[i];
      const end = stars[i+1];
      
      // 偶尔在线条上添加粒子
      if (Math.random() < 0.1) {
        const progress = Math.random();
        const x = start.x + (end.x - start.x) * progress;
        const y = start.y + (end.y - start.y) * progress;
        particles.push(new Particle(x, y));
      }
    }
  }
}

function highlightConstellation(){
  stars.forEach(s=>{
    s.brightness = 1;
    s.radius = s.targetRadius + 3;
  });
  
  // 激活星座发光效果
  constellationGlow.active = true;
  constellationGlow.radius = 0;
  constellationGlow.alpha = 0.5;
  
  // 在星星周围创建粒子爆发
  stars.forEach(star => {
    for (let i = 0; i < 10; i++) {
      particles.push(new Particle(star.x, star.y));
      sparkles.push(new Sparkle(star.x, star.y));
    }
  });
  
  // 显示星座名称
  const nameElement = document.createElement('div');
  nameElement.className = 'constellation-name';
  nameElement.textContent = constellationNames[Math.floor(Math.random() * constellationNames.length)];
  document.body.appendChild(nameElement);
  
  setTimeout(() => {
    nameElement.style.opacity = 1;
  }, 500);
  
  setTimeout(() => {
    nameElement.style.opacity = 0;
    setTimeout(() => {
      document.body.removeChild(nameElement);
    }, 1000);
  }, 3000);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  
  // 绘制背景流星
  meteors.forEach(meteor => {
    meteor.update();
    meteor.draw();
    if (!meteor.active) {
      meteor.reset();
    }
  });
  
  // 绘制星座发光效果
  if (constellationGlow.active) {
    ctx.save();
    ctx.beginPath();
    
    // 计算星座中心点
    let centerX = 0, centerY = 0;
    stars.forEach(star => {
      centerX += star.x;
      centerY += star.y;
    });
    centerX /= stars.length;
    centerY /= stars.length;
    
    // 计算最大半径
    let maxDistance = 0;
    stars.forEach(star => {
      const distance = Math.sqrt(
        Math.pow(star.x - centerX, 2) + Math.pow(star.y - centerY, 2)
      );
      if (distance > maxDistance) maxDistance = distance;
    });
    
    // 绘制发光效果
    const gradient = ctx.createRadialGradient(
      centerX, centerY, 0,
      centerX, centerY, maxDistance + constellationGlow.radius
    );
    gradient.addColorStop(0, `rgba(100, 150, 255, ${constellationGlow.alpha})`);
    gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
    
    ctx.fillStyle = gradient;
    ctx.arc(centerX, centerY, maxDistance + constellationGlow.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // 更新发光效果
    constellationGlow.radius += 2;
    constellationGlow.alpha -= 0.02;
    
    if (constellationGlow.alpha <= 0) {
      constellationGlow.active = false;
    }
    
    ctx.restore();
  }
  
  // 绘制星星和连线
  stars.forEach(s=>s.update());
  if(stars.length>1) connectStars();
  
  // 绘制和更新粒子
  particles.forEach((particle, index) => {
    particle.update();
    particle.draw();
    if (particle.life <= 0) {
      particles.splice(index, 1);
    }
  });
  
  // 绘制和更新闪光粒子
  sparkles.forEach((sparkle, index) => {
    sparkle.update();
    sparkle.draw();
    if (sparkle.life <= 0) {
      sparkles.splice(index, 1);
    }
  });
  
  requestAnimationFrame(draw);
}

canvas.addEventListener('click', e=>{
  if(stars.length >= maxStars) return;
  let star = new Star(e.clientX, e.clientY);
  stars.push(star);
  if(stars.length === maxStars){
    highlightConstellation(); // 星座强调效果
    setTimeout(showFortune, 2000); // 延迟显示运势
  }
});

function showFortune(){
  let isGood = Math.random()<0.8;
  let filtered = fortunes.filter(f=> isGood ? fortunes.indexOf(f)<40 : fortunes.indexOf(f)>=40);
  let f = filtered[Math.floor(Math.random()*filtered.length)];
  const box = document.getElementById('fortuneBox');
  const container = document.getElementById('fortuneContainer');
  
  box.innerText = f;
  container.style.display = 'block';
  
  // 添加显示动画
  container.style.opacity = 0;
  container.style.transform = 'translateX(-50%) scale(0.8)';
  setTimeout(() => {
    container.style.transition = 'opacity 0.5s, transform 0.5s';
    container.style.opacity = 1;
    container.style.transform = 'translateX(-50%) scale(1)';
  }, 100);
}

// 初始化流星
for (let i = 0; i < 5; i++) {
  meteors.push(new Meteor());
}

document.getElementById('storyBtn').addEventListener('click',()=>{
  window.location.href = "story.html";
});

window.addEventListener('resize',()=>{
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

draw();
</script>
</body>
</html>
